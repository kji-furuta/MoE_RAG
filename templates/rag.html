{% extends "base.html" %}

{% block title %}RAG System - AI Fine-tuning Toolkit{% endblock %}

{% block content %}
<style>
    /* RAGページ専用のスタイル調整 */
    .rag-container {
        padding-left: 40px;
        padding-right: 40px;
        padding-top: 20px;
    }
    
    .rag-container h1 {
        margin-bottom: 30px;
        padding-left: 10px;
    }
    
    .nav-tabs {
        margin-left: 0;
        margin-bottom: 20px;
        border-bottom: 2px solid #b3ecb1;
    }
    
    .nav-tabs .nav-link {
        padding: 10px 20px;
        border-radius: 5px 5px 0 0;
        color: #4d0505 !important;  /* タブの文字を黒色に */
        font-weight: 500;
    }
    
    .nav-tabs .nav-link:hover {
        color: #fc0b03 !important;  /* ホバー時も黒系統 */
    }
    
    .nav-tabs .nav-link.active {
        color: #1403fc !important;  /* アクティブタブも黒色 */
        font-weight: 600;
        background-color: #a4e3ee;
        border-color: #dee2e6 #dee2e6 #fff;
    }
    
    .tab-content {
        padding-top: 20px;
    }
    
    .card {
        margin-bottom: 20px;
        border: 1px solid #b0cfee;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .card-body {
        padding: 25px;
    }
    
    .form-control, .btn {
        margin-left: 0;
    }
    
    .form-label {
        margin-bottom: 8px;
        font-weight: 600;
    }
    
    /* テーブルのスタイル */
    .table {
        margin-left: 0;
        width: 100%;
    }
    
    /* アラートのスタイル */
    .alert {
        margin-left: 0;
        margin-right: 0;
        padding: 15px 20px;
    }
    
    /* フォームグループの間隔 */
    .mb-3 {
        margin-bottom: 1.5rem !important;
    }
    
    /* Bootstrap互換性のための調整 */
    .row {
        margin-left: -15px;
        margin-right: -15px;
    }
    
    .col-md-4 {
        padding-left: 15px;
        padding-right: 15px;
    }
    
    /* 回答表示用のスタイル */
    .answer-content {
        background-color: #f8f9fa;
        padding: 20px;
        border-radius: 8px;
        margin-top: 10px;
    }
    
    .citations-list {
        max-height: 400px;
        overflow-y: auto;
    }
    
    .citations-list .card {
        border: 1px solid #bb8c8c;
        box-shadow: none;
    }
    
    .citations-list .card:hover {
        background-color: #e7b7b7;
    }
</style>

<div class="container rag-container">
    <h1>🏗️ 土木道路設計特化型RAGシステム</h1>
    
    {% if not rag_available %}
    <div class="alert alert-warning">
        <h3>⚠️ RAGシステムは現在利用できません</h3>
        <p>RAGシステムの初期化中にエラーが発生しました。</p>
        <p>以下をお試しください：</p>
        <ul>
            <li>Dockerコンテナを再起動してください</li>
            <li>既存のQdrantプロセスを停止してください</li>
            <li>ログを確認してください: <code>docker logs ai-ft-container</code></li>
        </ul>
        <p>詳細: Qdrantデータベースが他のプロセスで使用されています</p>
    </div>
    {% else %}
    
    <!-- タブナビゲーション -->
    <ul class="nav nav-tabs mb-4">
        <li class="nav-item">
            <a class="nav-link active" data-bs-toggle="tab" href="#settings">⚙️ モデル設定</a>
        </li>
        <li class="nav-item">
            <a class="nav-link" data-bs-toggle="tab" href="#upload">📤 文書アップロード</a>
        </li>
        <li class="nav-item">
            <a class="nav-link" data-bs-toggle="tab" href="#search">🔍 検索・質問応答</a>
        </li>
        <li class="nav-item">
            <a class="nav-link" data-bs-toggle="tab" href="#documents">📚 文書管理</a>
        </li>
        <li class="nav-item">
            <a class="nav-link" data-bs-toggle="tab" href="#statistics">📊 統計情報</a>
        </li>
        <li class="nav-item">
            <a class="nav-link" data-bs-toggle="tab" href="#history">📋 検索履歴</a>
        </li>
    </ul>

    <!-- タブコンテンツ -->
    <div class="tab-content">
        <!-- モデル設定タブ -->
        <div class="tab-pane fade show active" id="settings">
            <div class="card">
                <div class="card-body">
                    <h3>⚙️ RAGシステム設定</h3>
                    
                    <div class="mb-4">
                        <h4>🤖 使用するAIモデル</h4>
                        <form id="modelSettingsForm">
                            <div class="mb-3">
                                <label for="ragModel" class="form-label">LLM（大規模言語モデル）選択</label>
                                <select class="form-control" id="ragModel" name="model">
                                    <option value="">モデルを選択してください...</option>
                                    <optgroup label="MoE（Mixture of Experts）モデル">
                                        <!-- MoEトレーニング済みモデルが動的に読み込まれます -->
                                    </optgroup>
                                    <optgroup label="ファインチューニング済みモデル">
                                        <!-- 動的に読み込まれます -->
                                    </optgroup>
                                    <optgroup label="Ollamaモデル">
                                        <option value="ollama:deepseek-32b-finetuned">DeepSeek-32B-Finetuned (ファインチューニング済み)</option>
                                        <option value="ollama:llama3.2:3b">Llama 3.2 3B</option>
                                    </optgroup>
                                    <optgroup label="ベースモデル">
                                        <option value="cyberagent/calm3-22b-chat">CALM3-22B-Chat (日本語特化)</option>
                                        <option value="microsoft/Phi-3.5-mini-instruct">Phi-3.5-mini (軽量)</option>
                                        <option value="meta-llama/Llama-2-7b-chat-hf">Llama-2-7B-Chat</option>
                                    </optgroup>
                                </select>
                                <small class="form-text text-muted">
                                    ファインチューニング済みモデルを使用すると、土木道路設計に特化した回答が得られます
                                </small>
                            </div>
                            
                            <div class="mb-3">
                                <label for="embeddingModel" class="form-label">埋め込みモデル</label>
                                <select class="form-control" id="embeddingModel" name="embedding_model">
                                    <option value="intfloat/multilingual-e5-large" selected>Multilingual-E5-Large (推奨)</option>
                                    <option value="sentence-transformers/all-MiniLM-L6-v2">All-MiniLM-L6-v2 (高速)</option>
                                    <option value="BAAI/bge-base-ja-v1.5">BGE-Base-JA (日本語特化)</option>
                                </select>
                            </div>
                            
                            <div class="mb-3">
                                <label for="temperature" class="form-label">Temperature (創造性)</label>
                                <input type="range" class="form-control-range" id="temperature" 
                                       name="temperature" min="0" max="1" step="0.1" value="0.3">
                                <span id="tempValue">0.3</span>
                                <small class="form-text text-muted">
                                    低い値: より正確で一貫性のある回答 / 高い値: より創造的な回答
                                </small>
                            </div>
                            
                            <button type="submit" class="btn btn-primary">設定を保存</button>
                            <div id="modelSettingsResult" class="mt-3"></div>
                        </form>
                    </div>
                    
                    <!-- 自動量子化機能セクション -->
                    <div class="mt-4">
                        <h4>🔧 ファインチューニング済みモデル量子化</h4>
                        <div class="card bg-light">
                            <div class="card-body">
                                <p class="text-muted">LoRAアダプタを量子化してOllamaで使用可能にします</p>
                                
                                <div id="quantizationForm">
                                    <div class="form-group">
                                        <label for="loraModel">LoRAモデル選択</label>
                                        <select class="form-control" id="loraModel" name="loraModel" required>
                                            <option value="">-- 読み込み中... --</option>
                                        </select>
                                        <small class="form-text text-muted" id="loraModelInfo"></small>
                                    </div>
                                    
                                    <div class="form-group mt-3">
                                        <label for="quantizationLevel">量子化レベル</label>
                                        <select class="form-control" id="quantizationLevel" name="quantizationLevel">
                                            <option value="Q4_K_M" selected>Q4_K_M (4-bit, ~16GB) - 推奨</option>
                                            <option value="Q5_K_M">Q5_K_M (5-bit, ~20GB)</option>
                                            <option value="Q8_0">Q8_0 (8-bit, ~32GB)</option>
                                        </select>
                                        <small class="form-text text-muted">
                                            Q4_K_M: メモリ効率と品質のバランスが最適
                                        </small>
                                    </div>
                                    
                                    <div class="form-group mt-3">
                                        <label for="modelName">Ollamaモデル名</label>
                                        <input type="text" class="form-control" id="modelName" 
                                               name="modelName" value="rag-deepseek-q4" placeholder="例: rag-deepseek-q4" required>
                                        <small class="form-text text-muted">
                                            Ollamaで使用するモデル名を指定（英数字とハイフンのみ）
                                        </small>
                                    </div>
                                    
                                    <button type="button" class="btn btn-warning" id="quantizeBtn" onclick="startQuantization()">
                                        <i class="fas fa-compress"></i> 量子化開始
                                    </button>
                                    <button type="button" class="btn btn-secondary ml-2" id="checkStatusBtn" style="display:none;">
                                        <i class="fas fa-sync"></i> 進捗確認
                                    </button>
                                </div>
                                
                                <!-- 量子化進捗表示 -->
                                <div id="quantizationProgress" class="mt-3" style="display:none;">
                                    <div class="progress">
                                        <div class="progress-bar progress-bar-striped progress-bar-animated" 
                                             role="progressbar" style="width: 0%"></div>
                                    </div>
                                    <div id="quantizationStatus" class="mt-2 text-muted"></div>
                                    <div id="quantizationLog" class="mt-2 p-2 bg-dark text-light" 
                                         style="font-family: monospace; font-size: 12px; max-height: 200px; overflow-y: auto; display:none;">
                                    </div>
                                </div>
                                
                                <!-- 量子化結果 -->
                                <div id="quantizationResult" class="mt-3"></div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="mt-4">
                        <h4>📊 現在の設定</h4>
                        <div id="currentSettings" class="alert alert-info">
                            読み込み中...
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- アップロードタブ -->
        <div class="tab-pane fade" id="upload">
            <div class="card">
                <div class="card-body">
                    <h3>📤 PDF文書アップロード</h3>
                    <form id="uploadForm" enctype="multipart/form-data">
                        <div class="mb-3">
                            <label for="file" class="form-label">PDFファイル選択</label>
                            <input type="file" class="form-control" id="file" name="file" accept=".pdf" required>
                        </div>
                        <div class="mb-3">
                            <label for="title" class="form-label">文書タイトル</label>
                            <input type="text" class="form-control" id="title" name="title" required>
                        </div>
                        <div class="mb-3">
                            <label for="category" class="form-label">カテゴリ</label>
                            <select class="form-control" id="category" name="category" required>
                                <option value="道路構造令">道路構造令</option>
                                <option value="設計基準">設計基準</option>
                                <option value="技術マニュアル">技術マニュアル</option>
                                <option value="仕様書">仕様書</option>
                                <option value="その他">その他</option>
                            </select>
                        </div>
                        <button type="submit" class="btn btn-primary">アップロード</button>
                    </form>
                    <div id="uploadResult" class="mt-3"></div>
                </div>
            </div>
        </div>

        <!-- 検索タブ -->
        <div class="tab-pane fade" id="search">
            <div class="card">
                <div class="card-body">
                    <h3>🔍 ハイブリッド検索・質問応答</h3>
                    
                    <!-- 文書選択セクション -->
                    <div class="card mb-3 bg-light">
                        <div class="card-body">
                            <h5>📄 検索対象文書の選択</h5>
                            <div class="form-check mb-2">
                                <input class="form-check-input" type="checkbox" id="selectAllDocuments" checked>
                                <label class="form-check-label" for="selectAllDocuments">
                                    <strong>すべての文書を選択</strong>
                                </label>
                            </div>
                            <div id="documentCheckboxList" class="row"></div>
                            <small class="text-muted">※選択された文書のみから検索されます</small>
                        </div>
                    </div>
                    
                    <form id="searchForm">
                        <div class="mb-3">
                            <label for="query" class="form-label">検索クエリ・質問</label>
                            <textarea class="form-control" id="query" rows="3" required
                                placeholder="例: 設計速度60km/hの道路の最小曲線半径は？"></textarea>
                        </div>
                        <div class="mb-3">
                            <label for="searchType" class="form-label">検索タイプ</label>
                            <select class="form-control" id="searchType">
                                <option value="hybrid">ハイブリッド検索（推奨）</option>
                                <option value="vector">ベクトル検索</option>
                                <option value="keyword">キーワード検索</option>
                            </select>
                        </div>
                        <div class="mb-3">
                            <label for="topK" class="form-label">検索結果数</label>
                            <input type="number" class="form-control" id="topK" value="5" min="1" max="20">
                        </div>
                        <button type="submit" class="btn btn-primary">検索</button>
                    </form>
                    <div id="searchResult" class="mt-4"></div>
                </div>
            </div>
        </div>

        <!-- 文書管理タブ -->
        <div class="tab-pane fade" id="documents">
            <div class="card">
                <div class="card-body">
                    <h3>📚 文書一覧</h3>
                    <button class="btn btn-secondary mb-3" onclick="loadDocuments()">更新</button>
                    <div id="documentsList"></div>
                </div>
            </div>
        </div>

        <!-- 統計タブ -->
        <div class="tab-pane fade" id="statistics">
            <div class="card">
                <div class="card-body">
                    <h3>📊 システム統計</h3>
                    <button class="btn btn-secondary mb-3" onclick="loadStatistics()">更新</button>
                    <div id="statisticsData"></div>
                </div>
            </div>
        </div>

        <!-- 検索履歴タブ -->
        <div class="tab-pane fade" id="history">
            <div class="card">
                <div class="card-body">
                    <h3>📋 検索履歴</h3>
                    <div class="mb-3">
                        <button class="btn btn-primary" onclick="loadSearchHistory()">
                            <i class="bi bi-arrow-clockwise"></i> 履歴を更新
                        </button>
                        <button class="btn btn-success" onclick="exportAllHistory()">
                            <i class="bi bi-download"></i> 全履歴をエクスポート
                        </button>
                        <button class="btn btn-danger float-end" onclick="clearAllSearchHistory()">
                            <i class="bi bi-trash"></i> 全履歴を削除
                        </button>
                    </div>
                    
                    <div class="mb-3">
                        <label for="tagFilter" class="form-label">タグでフィルタ</label>
                        <select class="form-control" id="tagFilter" onchange="loadSearchHistory()">
                            <option value="">すべて</option>
                        </select>
                    </div>
                    
                    <div id="historyList">
                        <div class="text-muted">「履歴を更新」ボタンをクリックして履歴を読み込んでください</div>
                    </div>
                    
                    <nav aria-label="履歴ページネーション">
                        <ul class="pagination justify-content-center" id="historyPagination">
                        </ul>
                    </nav>
                </div>
            </div>
        </div>
    </div>
    {% endif %}
</div>

<script>
// アップロードフォーム
document.getElementById('uploadForm')?.addEventListener('submit', async (e) => {
    e.preventDefault();
    const formData = new FormData(e.target);
    const resultDiv = document.getElementById('uploadResult');
    
    resultDiv.innerHTML = '<div class="alert alert-info">アップロード中...</div>';
    
    try {
        const response = await fetch('/rag/upload-document', {
            method: 'POST',
            body: formData
        });
        
        const data = await response.json();
        
        if (response.ok) {
            // アップロードは成功、処理状況を監視
            const documentId = data.document_id;
            
            // プログレスバー表示
            resultDiv.innerHTML = `
                <div class="alert alert-info">
                    <h4>アップロード完了 - 処理中...</h4>
                    <p>文書ID: ${documentId}</p>
                    <div class="progress">
                        <div id="uploadProgress" class="progress-bar progress-bar-striped progress-bar-animated" 
                             role="progressbar" style="width: 0%">0%</div>
                    </div>
                    <p id="statusMessage" class="mt-2">初期化中...</p>
                </div>
            `;
            
            // ステータスチェック関数
            async function checkStatus() {
                try {
                    const statusResponse = await fetch(`/rag/upload-status/${documentId}`);
                    const statusData = await statusResponse.json();
                    
                    const progressBar = document.getElementById('uploadProgress');
                    const statusMsg = document.getElementById('statusMessage');
                    
                    if (progressBar && statusMsg) {
                        progressBar.style.width = `${statusData.progress}%`;
                        progressBar.textContent = `${statusData.progress}%`;
                        statusMsg.textContent = statusData.message || '処理中...';
                        
                        // ステータスに応じて処理
                        if (statusData.status === 'completed') {
                            resultDiv.innerHTML = `
                                <div class="alert alert-success">
                                    <h4>✅ 処理完了</h4>
                                    <p>文書ID: ${documentId}</p>
                                    <p>${statusData.message}</p>
                                </div>
                            `;
                            // 文書リストを更新
                            await loadDocumentCheckboxList();
                            if (typeof loadDocuments === 'function') {
                                await loadDocuments();
                            }
                            // フォームをリセット
                            e.target.reset();
                            return true; // 完了
                        } else if (statusData.status === 'error' || statusData.status === 'timeout') {
                            resultDiv.innerHTML = `
                                <div class="alert alert-danger">
                                    <h4>❌ 処理エラー</h4>
                                    <p>文書ID: ${documentId}</p>
                                    <p>${statusData.message}</p>
                                </div>
                            `;
                            return true; // エラーで終了
                        }
                    }
                    return false; // 継続
                } catch (error) {
                    console.error('Status check error:', error);
                    return false; // エラーでも継続
                }
            }
            
            // 定期的にステータスをチェック
            const intervalId = setInterval(async () => {
                const isComplete = await checkStatus();
                if (isComplete) {
                    clearInterval(intervalId);
                }
            }, 2000); // 2秒ごとにチェック
            
            // 最大20分でタイムアウト
            setTimeout(() => {
                clearInterval(intervalId);
                resultDiv.innerHTML = `
                    <div class="alert alert-warning">
                        <h4>⚠️ タイムアウト</h4>
                        <p>処理の確認がタイムアウトしました。バックグラウンドで処理が継続している可能性があります。</p>
                    </div>
                `;
            }, 1200000); // 20分
            
        } else {
            throw new Error(data.detail || 'アップロードエラー');
        }
    } catch (error) {
        resultDiv.innerHTML = `
            <div class="alert alert-danger">
                エラー: ${error.message}
            </div>
        `;
    }
});

// 検索フォーム
document.getElementById('searchForm')?.addEventListener('submit', async (e) => {
    e.preventDefault();
    const query = document.getElementById('query').value;
    const searchType = document.getElementById('searchType').value;
    const topK = document.getElementById('topK').value;
    const resultDiv = document.getElementById('searchResult');
    
    // 選択された文書IDを取得
    const selectedDocuments = [];
    const selectAllCheckbox = document.getElementById('selectAllDocuments');
    
    // 「すべての文書を選択」がチェックされている場合は、document_idsを送信しない（全文書が対象）
    if (!selectAllCheckbox || !selectAllCheckbox.checked) {
        // 個別選択されている文書のみを取得
        const checkboxes = document.querySelectorAll('.document-checkbox:checked');
        checkboxes.forEach(checkbox => {
            selectedDocuments.push(checkbox.value);
        });
        
        // 何も選択されていない場合は警告
        if (selectedDocuments.length === 0) {
            resultDiv.innerHTML = `
                <div class="alert alert-warning">
                    <strong>⚠️ 文書が選択されていません</strong><br>
                    検索対象の文書を選択してください。
                </div>
            `;
            return;
        }
    }
    
    resultDiv.innerHTML = '<div class="alert alert-info">検索中...</div>';
    
    try {
        const requestBody = {
            query: query,
            search_type: searchType,
            top_k: parseInt(topK),
            include_sources: true
        };
        
        // 選択されたモデルを追加
        const selectedModel = document.getElementById('ragModel')?.value;
        if (selectedModel && selectedModel !== '') {
            requestBody.model = selectedModel;
            console.log('Using model:', selectedModel);
        }
        
        // 特定の文書が選択されている場合のみdocument_idsを追加
        // 「すべての文書を選択」の場合はdocument_idsを送信しない
        if (selectedDocuments.length > 0) {
            requestBody.document_ids = selectedDocuments;
            console.log('Filtering by documents:', selectedDocuments);
        } else {
            console.log('Searching all documents');
        }
        
        const response = await fetch('/rag/query', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestBody)
        });
        
        const data = await response.json();
        
        if (response.ok) {
            displaySearchResult(data);
        } else {
            throw new Error(data.detail || '検索エラー');
        }
    } catch (error) {
        resultDiv.innerHTML = `
            <div class="alert alert-danger">
                エラー: ${error.message}
            </div>
        `;
    }
});

// 文書一覧取得
async function loadDocuments() {
    const listDiv = document.getElementById('documentsList');
    listDiv.innerHTML = '<div class="alert alert-info">読み込み中...</div>';
    
    try {
        const response = await fetch('/rag/documents');
        const data = await response.json();
        
        if (response.ok && data.documents) {
            let html = '<table class="table">';
            html += '<thead><tr><th>タイトル</th><th>カテゴリ</th><th>ページ数</th><th>アップロード日時</th><th>操作</th></tr></thead>';
            html += '<tbody>';
            
            data.documents.forEach(doc => {
                // 日時の取得（created_at または processing_timestamp を使用）
                let uploadDate = '-';
                if (doc.created_at) {
                    // ISOフォーマットまたは通常の日時形式をパース
                    const date = new Date(doc.created_at);
                    if (!isNaN(date)) {
                        uploadDate = date.toLocaleString('ja-JP', { 
                            timeZone: 'Asia/Tokyo',
                            year: 'numeric',
                            month: '2-digit',
                            day: '2-digit',
                            hour: '2-digit',
                            minute: '2-digit',
                            second: '2-digit'
                        });
                    }
                } else if (doc.processing_timestamp) {
                    const date = new Date(doc.processing_timestamp);
                    if (!isNaN(date)) {
                        uploadDate = date.toLocaleString('ja-JP', { 
                            timeZone: 'Asia/Tokyo',
                            year: 'numeric',
                            month: '2-digit',
                            day: '2-digit',
                            hour: '2-digit',
                            minute: '2-digit',
                            second: '2-digit'
                        });
                    }
                }
                
                html += `<tr id="doc-row-${doc.id}">
                    <td>${doc.title}</td>
                    <td>${doc.category}</td>
                    <td>${doc.page_count || '-'}</td>
                    <td>${uploadDate}</td>
                    <td>
                        <button class="btn btn-sm btn-danger" onclick="deleteDocument('${doc.id}', '${doc.title}')">
                            削除
                        </button>
                    </td>
                </tr>`;
            });
            
            html += '</tbody></table>';
            listDiv.innerHTML = html;
        } else {
            throw new Error('文書一覧の取得に失敗しました');
        }
    } catch (error) {
        listDiv.innerHTML = `<div class="alert alert-danger">エラー: ${error.message}</div>`;
    }
}

// 文書削除
async function deleteDocument(docId, docTitle) {
    if (!confirm(`文書「${docTitle}」を削除してもよろしいですか？\n\nこの操作は取り消せません。`)) {
        return;
    }
    
    try {
        const response = await fetch(`/rag/documents/${docId}`, {
            method: 'DELETE'
        });
        
        const data = await response.json();
        
        if (response.ok) {
            // 成功メッセージを表示
            const alertDiv = document.createElement('div');
            alertDiv.className = 'alert alert-success alert-dismissible fade show';
            alertDiv.innerHTML = `
                <strong>削除成功:</strong> ${data.document_title} を削除しました。
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            `;
            document.getElementById('documentsList').insertBefore(alertDiv, document.getElementById('documentsList').firstChild);
            
            // 行を削除
            const row = document.getElementById(`doc-row-${docId}`);
            if (row) {
                row.style.transition = 'opacity 0.5s';
                row.style.opacity = '0';
                setTimeout(() => row.remove(), 500);
            }
        } else {
            throw new Error(data.detail || '削除に失敗しました');
        }
    } catch (error) {
        alert(`削除エラー: ${error.message}`);
    }
}

// 量子化開始関数
async function startQuantization() {
    
    const quantizeBtn = document.getElementById('quantizeBtn');
    const checkStatusBtn = document.getElementById('checkStatusBtn');
    const progressDiv = document.getElementById('quantizationProgress');
    const statusDiv = document.getElementById('quantizationStatus');
    const logDiv = document.getElementById('quantizationLog');
    const resultDiv = document.getElementById('quantizationResult');
    
    // フォームデータを取得
    const loraModel = document.getElementById('loraModel').value;
    const quantizationLevel = document.getElementById('quantizationLevel').value;
    const modelName = document.getElementById('modelName').value;
    
    // 入力検証
    if (!loraModel || !modelName) {
        resultDiv.innerHTML = `
            <div class="alert alert-warning">
                <strong>入力エラー:</strong> LoRAモデルとモデル名を入力してください。
            </div>
        `;
        return;
    }
    
    // FormDataを手動で作成（フィールド名を明示的に設定）
    const formData = new FormData();
    formData.append('lora_path', loraModel);
    formData.append('quantization_level', quantizationLevel);
    formData.append('model_name', modelName);
    
    // UIをリセット
    quantizeBtn.disabled = true;
    checkStatusBtn.style.display = 'inline-block';
    progressDiv.style.display = 'block';
    resultDiv.innerHTML = '';
    
    try {
        // 量子化開始
        const response = await fetch('/rag/quantize-model', {
            method: 'POST',
            body: formData
        });
        
        const data = await response.json();
        
        if (response.ok) {
            // ステータス監視開始
            const taskId = data.task_id;
            statusDiv.textContent = data.message;
            
            // 定期的にステータスをチェック
            const checkInterval = setInterval(async () => {
                try {
                    const statusResponse = await fetch(`/rag/quantization-status/${taskId}`);
                    const statusData = await statusResponse.json();
                    
                    // プログレスバー更新
                    const progressBar = progressDiv.querySelector('.progress-bar');
                    progressBar.style.width = `${statusData.progress}%`;
                    progressBar.textContent = `${statusData.progress}%`;
                    
                    // ステータステキスト更新
                    statusDiv.textContent = statusData.message;
                    
                    // ログ表示
                    if (statusData.logs && statusData.logs.length > 0) {
                        logDiv.style.display = 'block';
                        logDiv.innerHTML = statusData.logs.join('<br>');
                        logDiv.scrollTop = logDiv.scrollHeight;
                    }
                    
                    // 完了または エラー時
                    if (statusData.status === 'completed') {
                        clearInterval(checkInterval);
                        quantizeBtn.disabled = false;
                        checkStatusBtn.style.display = 'none';
                        
                        resultDiv.innerHTML = `
                            <div class="alert alert-success">
                                <h5>✅ 量子化完了</h5>
                                <p>${statusData.message}</p>
                                <p>Ollamaモデル名: <code>${statusData.ollama_model}</code></p>
                                <hr>
                                <p>このモデルを使用してハイブリッド検索を実行できます。</p>
                                <button class="btn btn-primary" onclick="updateModelSettings('${statusData.ollama_model}')">
                                    このモデルを使用する
                                </button>
                            </div>
                        `;
                        
                        // 現在の設定を更新
                        loadCurrentSettings();
                        
                    } else if (statusData.status === 'error' || statusData.status === 'failed') {
                        clearInterval(checkInterval);
                        quantizeBtn.disabled = false;
                        checkStatusBtn.style.display = 'none';
                        
                        resultDiv.innerHTML = `
                            <div class="alert alert-danger">
                                <h5>❌ エラー</h5>
                                <p>${statusData.message}</p>
                            </div>
                        `;
                    }
                    
                } catch (error) {
                    console.error('ステータス取得エラー:', error);
                }
            }, 2000); // 2秒ごとにチェック
            
            // 手動ステータスチェックボタン
            checkStatusBtn.onclick = async () => {
                try {
                    const statusResponse = await fetch(`/rag/quantization-status/${taskId}`);
                    const statusData = await statusResponse.json();
                    
                    // ステータスメッセージを表示
                    statusDiv.innerHTML = `
                        <div class="alert alert-info">
                            <strong>状態:</strong> ${statusData.status}<br>
                            <strong>メッセージ:</strong> ${statusData.message}
                            ${statusData.current_step ? `<br><strong>現在のステップ:</strong> ${statusData.current_step}` : ''}
                            ${statusData.progress ? `<br><strong>進捗:</strong> ${statusData.progress}%` : ''}
                        </div>
                    `;
                    
                    // 完了または失敗の場合は結果を表示
                    if (statusData.status === 'completed') {
                        resultDiv.innerHTML = `
                            <div class="alert alert-success">
                                <strong>✅ 量子化完了！</strong><br>
                                ${statusData.message}
                            </div>
                        `;
                        checkStatusBtn.style.display = 'none';
                        clearInterval(checkInterval);
                    } else if (statusData.status === 'failed') {
                        resultDiv.innerHTML = `
                            <div class="alert alert-danger">
                                <strong>❌ エラー</strong><br>
                                ${statusData.message}
                            </div>
                        `;
                        checkStatusBtn.style.display = 'none';
                        clearInterval(checkInterval);
                    }
                } catch (error) {
                    statusDiv.innerHTML = `
                        <div class="alert alert-warning">
                            <strong>進捗確認エラー:</strong> ${error.message}
                        </div>
                    `;
                }
            };
            
        } else {
            throw new Error(data.detail || '量子化開始に失敗しました');
        }
        
    } catch (error) {
        quantizeBtn.disabled = false;
        checkStatusBtn.style.display = 'none';
        resultDiv.innerHTML = `
            <div class="alert alert-danger">
                <strong>エラー:</strong> ${error.message}
            </div>
        `;
    }
}

// 量子化済みモデルを設定に適用
async function updateModelSettings(modelName) {
    try {
        const response = await fetch('/rag/update-settings', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                'llm.use_ollama_fallback': true,
                'llm.ollama_model': modelName
            })
        });
        
        if (response.ok) {
            alert(`モデル '${modelName}' が設定されました。ハイブリッド検索で使用できます。`);
            loadCurrentSettings();
        }
    } catch (error) {
        alert(`設定更新エラー: ${error.message}`);
    }
}

// 統計情報取得
async function loadStatistics() {
    const statsDiv = document.getElementById('statisticsData');
    statsDiv.innerHTML = '<div class="alert alert-info">読み込み中...</div>';
    
    try {
        const response = await fetch('/rag/statistics');
        const data = await response.json();
        
        if (response.ok) {
            let html = '<div class="row">';
            html += `
                <div class="col-md-4">
                    <div class="card text-center">
                        <div class="card-body">
                            <h5>総文書数</h5>
                            <h2>${data.total_documents || 0}</h2>
                        </div>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="card text-center">
                        <div class="card-body">
                            <h5>総チャンク数</h5>
                            <h2>${data.total_chunks || 0}</h2>
                        </div>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="card text-center">
                        <div class="card-body">
                            <h5>インデックスサイズ</h5>
                            <h2>${data.index_size || 'N/A'}</h2>
                        </div>
                    </div>
                </div>
            `;
            html += '</div>';
            statsDiv.innerHTML = html;
        } else {
            throw new Error('統計情報の取得に失敗しました');
        }
    } catch (error) {
        statsDiv.innerHTML = `<div class="alert alert-danger">エラー: ${error.message}</div>`;
    }
}

// Temperature スライダーの値を表示
document.getElementById('temperature')?.addEventListener('input', (e) => {
    document.getElementById('tempValue').textContent = e.target.value;
});

// ファインチューニング済みモデルとMoEモデルを読み込む
async function loadFinetunedModels() {
    try {
        // ファインチューニング済みモデルを取得
        const response = await fetch('/api/available-models');
        const data = await response.json();
        
        const select = document.getElementById('ragModel');
        const finetunedOptgroup = select.querySelector('optgroup[label="ファインチューニング済みモデル"]');
        const moeOptgroup = select.querySelector('optgroup[label="MoE（Mixture of Experts）モデル"]');
        const ollamaOptgroup = select.querySelector('optgroup[label="Ollamaモデル"]');
        
        // 既存のオプションをクリア
        finetunedOptgroup.innerHTML = '';
        moeOptgroup.innerHTML = '';
        ollamaOptgroup.innerHTML = '';
        
        // MoEトレーニング履歴を取得
        try {
            const moeResponse = await fetch('/api/moe/training/history');
            const moeData = await moeResponse.json();
            
            if (moeData.history && moeData.history.length > 0) {
                // 完了したMoEモデルのみ表示
                const completedMoEModels = moeData.history.filter(task => task.status === 'completed');
                
                completedMoEModels.forEach(task => {
                    const option = document.createElement('option');
                    option.value = `moe:${task.task_id}`;
                    const experts = task.config.experts ? task.config.experts.join(', ') : '全エキスパート';
                    option.textContent = `MoE - ${task.config.training_type} (${experts}) - ${new Date(task.start_time).toLocaleDateString('ja-JP')}`;
                    moeOptgroup.appendChild(option);
                });
                
                if (completedMoEModels.length === 0) {
                    const option = document.createElement('option');
                    option.value = '';
                    option.textContent = 'トレーニング済みMoEモデルがありません';
                    option.disabled = true;
                    moeOptgroup.appendChild(option);
                }
            } else {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = 'MoEモデルが利用できません';
                option.disabled = true;
                moeOptgroup.appendChild(option);
            }
        } catch (moeError) {
            console.error('MoEモデルの取得に失敗:', moeError);
            const option = document.createElement('option');
            option.value = '';
            option.textContent = 'MoEモデルの読み込みに失敗しました';
            option.disabled = true;
            moeOptgroup.appendChild(option);
        }
        
        // ファインチューニング済みモデルを追加（継続学習モデルも含む）
        if (data.finetuned_models && data.finetuned_models.length > 0) {
            data.finetuned_models.forEach(model => {
                const option = document.createElement('option');
                option.value = `finetuned:${model.path}`;
                
                // モデルタイプに応じて表示名を調整
                let displayName = model.name;
                if (model.type === '継続学習' || model.type === '継続学習 (EWC)') {
                    displayName = `[継続学習] ${model.name}`;
                } else if (model.type === 'フルファインチューニング') {
                    displayName = `[フル] ${model.name}`;
                } else if (model.type === 'LoRA' || model.type === 'QLoRA (4bit)') {
                    displayName = `[${model.type}] ${model.name}`;
                }
                
                option.textContent = `${displayName} (${model.base_model || 'Unknown'}) - ${model.created_at || ''}`;
                finetunedOptgroup.appendChild(option);
            });
        } else {
            const option = document.createElement('option');
            option.value = '';
            option.textContent = 'ファインチューニング済みモデルがありません';
            option.disabled = true;
            finetunedOptgroup.appendChild(option);
        }
        
        // Ollamaモデルを追加
        if (data.ollama_models && data.ollama_models.length > 0) {
            data.ollama_models.forEach(model => {
                const option = document.createElement('option');
                option.value = `ollama:${model.name}`;
                
                // モデル名の表示を調整
                let displayName = model.name;
                if (model.name.includes('deepseek-32b-rag')) {
                    displayName = 'DeepSeek-32B RAG (Q4_K_M量子化)';
                } else if (model.name.includes('deepseek-32b-finetuned')) {
                    displayName = 'DeepSeek-32B (ファインチューニング済み)';
                } else if (model.name.includes('llama3.2:3b')) {
                    displayName = 'Llama 3.2 3B';
                } else if (model.name.includes('llama3.2')) {
                    displayName = `Llama 3.2 ${model.size || ''}`;
                } else if (model.name.includes('deepseek-r1:32b')) {
                    displayName = 'DeepSeek-R1 32B';
                }
                
                // サイズ情報がある場合は追加（ただしConfiguredとFrom configは除く）
                if (model.size && model.size !== 'Configured' && model.size !== 'From config') {
                    displayName += ` (${model.size})`;
                }
                
                option.textContent = displayName;
                ollamaOptgroup.appendChild(option);
            });
        } else {
            // デフォルトのOllamaモデルを表示
            const defaultModels = [
                { value: 'ollama:llama3.2:3b', text: 'Llama 3.2 3B (デフォルト)' },
                { value: 'ollama:deepseek-32b-finetuned', text: 'DeepSeek-32B (ファインチューニング済み)' },
                { value: 'ollama:deepseek-32b-rag', text: 'DeepSeek-32B RAG (Q4_K_M量子化)' }
            ];
            
            defaultModels.forEach(model => {
                const option = document.createElement('option');
                option.value = model.value;
                option.textContent = model.text;
                ollamaOptgroup.appendChild(option);
            });
        }
        
    } catch (error) {
        console.error('Failed to load models:', error);
    }
}

// LoRAモデルを動的に読み込む
async function loadLoRAModels() {
    try {
        console.log('Loading LoRA models...');
        const response = await fetch('/rag/list-lora-models');
        const data = await response.json();
        
        const loraSelect = document.getElementById('loraModel');
        const modelInfo = document.getElementById('loraModelInfo');
        
        if (!loraSelect) {
            console.log('LoRA model select element not found');
            return;
        }
        
        // セレクトボックスをクリア
        loraSelect.innerHTML = '';
        
        // デフォルトオプション
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = '-- LoRAモデルを選択 --';
        loraSelect.appendChild(defaultOption);
        
        if (data.models && data.models.length > 0) {
            // モデルタイプごとにグループ化
            const modelGroups = {};
            
            data.models.forEach(model => {
                const type = model.type || 'lora_adapter';
                if (!modelGroups[type]) {
                    modelGroups[type] = [];
                }
                modelGroups[type].push(model);
            });
            
            // グループごとにオプションを追加
            const typeLabels = {
                'ollama_ready': '✅ 使用可能（Ollama登録済み）',
                'gguf_model': '📦 GGUF形式',
                'merged_model': '🔀 マージ済みモデル',
                'lora_adapter': '🎯 LoRAアダプター',
                'continual_model': '📚 継続学習モデル',
                'auto': '🔍 自動検出'
            };
            
            Object.keys(typeLabels).forEach(groupType => {
                const modelsInGroup = modelGroups[groupType] || [];
                
                if (modelsInGroup.length > 0) {
                    // グループラベルを追加
                    const optgroup = document.createElement('optgroup');
                    optgroup.label = typeLabels[groupType];
                    
                    modelsInGroup.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model.path;
                        
                        // 表示名を決定（display_nameがあればそれを使用）
                        let displayName = model.display_name || model.name;
                        
                        // base_modelがある場合は追加情報として表示
                        if (model.base_model && model.base_model !== 'Unknown' && model.base_model !== '自動') {
                            const baseName = model.base_model.split('/').pop();
                            if (!displayName.includes(baseName)) {
                                displayName += ` (${baseName})`;
                            }
                        }
                        
                        // 推奨モデルにマーク
                        if (model.recommended || model.ready_to_use) {
                            option.textContent = `⭐ ${displayName}`;
                            option.style.fontWeight = 'bold';
                        } else {
                            option.textContent = displayName;
                        }
                        
                        // データ属性を追加（新旧両方の形式に対応）
                        option.setAttribute('data-base-model', model.base_model || 'Unknown');
                        option.setAttribute('data-size', model.size_mb || (model.size_gb ? model.size_gb * 1024 : 0));
                        option.setAttribute('data-type', model.type || 'lora_adapter');
                        option.setAttribute('data-needs-processing', model.needs_processing || 'none');
                        
                        optgroup.appendChild(option);
                    });
                    
                    loraSelect.appendChild(optgroup);
                }
            });
            
            // 最初の推奨モデルを自動選択
            const recommendedModel = data.models.find(m => m.ready_to_use || m.recommended);
            if (recommendedModel) {
                loraSelect.value = recommendedModel.path;
                if (modelInfo) {
                    const size = recommendedModel.size_mb || (recommendedModel.size_gb ? recommendedModel.size_gb * 1024 : 0);
                    const baseModel = recommendedModel.base_model || recommendedModel.display_name || recommendedModel.name;
                    modelInfo.textContent = `選択中: ${baseModel} (${size > 0 ? size.toFixed(2) + ' MB' : 'サイズ不明'})`;
                }
            }
            
            // 選択変更時の情報更新
            loraSelect.addEventListener('change', function() {
                const selected = loraSelect.options[loraSelect.selectedIndex];
                if (selected && selected.value && modelInfo) {
                    const baseModel = selected.getAttribute('data-base-model');
                    const size = parseFloat(selected.getAttribute('data-size') || 0);
                    const type = selected.getAttribute('data-type');
                    const needsProcessing = selected.getAttribute('data-needs-processing');
                    
                    let info = `タイプ: ${typeLabels[type] || type}`;
                    if (baseModel && baseModel !== 'Unknown') {
                        info += ` | ベース: ${baseModel}`;
                    }
                    if (size > 0) {
                        info += ` | サイズ: ${size.toFixed(2)} MB`;
                    }
                    if (needsProcessing && needsProcessing !== 'none') {
                        info += ` | 要処理: ${needsProcessing}`;
                    }
                    
                    modelInfo.textContent = info;
                } else if (modelInfo) {
                    modelInfo.textContent = '';
                }
            });
        } else {
            // モデルが見つからない場合でも自動検出オプションを追加
            const option = document.createElement('option');
            option.value = 'auto';
            option.textContent = '🔍 最新のLoRAモデルを自動検出';
            loraSelect.appendChild(option);
            
            if (modelInfo) {
                modelInfo.textContent = 'ファインチューニング済みモデルが見つかりません。自動検出モードを使用します。';
            }
        }
        
        console.log(`Loaded ${data.count} LoRA models`);
    } catch (error) {
        console.error('Failed to load LoRA models:', error);
        const loraSelect = document.getElementById('loraModel');
        if (loraSelect) {
            loraSelect.innerHTML = '<option value="">エラー: モデルの読み込みに失敗しました</option>';
            loraSelect.disabled = true;
        }
    }
}

// 現在の設定を読み込む
async function loadCurrentSettings() {
    try {
        console.log('Loading current settings...');
        const response = await fetch('/rag/system-info');
        console.log('Response status:', response.status);
        
        const data = await response.json();
        console.log('Response data:', data);
        
        const settingsDiv = document.getElementById('currentSettings');
        
        if (data.system_info && data.system_info.config) {
            const config = data.system_info.config;
            let html = '<table class="table table-sm">';
            
            // LLMモデルの詳細表示
            const modelName = config.llm?.model_name || '未設定';
            const isFinetunedModel = modelName.includes('outputs/') || modelName.includes('フルファインチューニング');
            const isMoEModel = config.llm?.use_moe === true;
            
            let modelType = 'ベースモデル';
            let badgeClass = 'bg-secondary';
            if (isMoEModel) {
                modelType = 'MoEモデル';
                badgeClass = 'bg-warning';
            } else if (isFinetunedModel) {
                modelType = 'ファインチューニング済み';
                badgeClass = 'bg-success';
            }
            
            html += `<tr><td><strong>使用中のLLMモデル:</strong></td><td><span class="badge ${badgeClass}">${modelType}</span><br><code>${modelName}</code></td></tr>`;
            
            // MoE設定がある場合は追加情報を表示
            if (isMoEModel) {
                html += `<tr><td>MoEエキスパート数:</td><td>${config.llm?.moe_num_experts || 8}</td></tr>`;
                html += `<tr><td>トークンごとのエキスパート:</td><td>${config.llm?.moe_experts_per_token || 2}</td></tr>`;
            }
            
            html += `<tr><td>埋め込みモデル:</td><td>${config.embedding?.model_name || 'multilingual-e5-large'}</td></tr>`;
            html += `<tr><td>Temperature:</td><td>${config.llm?.temperature || 0.3}</td></tr>`;
            html += `<tr><td>ベクトルストア:</td><td>${config.vector_store?.type || 'Qdrant'}</td></tr>`;
            html += `<tr><td>ファインチューニング使用:</td><td><span class="badge ${config.llm?.use_finetuned ? 'bg-success' : 'bg-secondary'}">${config.llm?.use_finetuned ? '有効' : '無効'}</span></td></tr>`;
            html += `<tr><td>MoE使用:</td><td><span class="badge ${config.llm?.use_moe ? 'bg-warning' : 'bg-secondary'}">${config.llm?.use_moe ? '有効' : '無効'}</span></td></tr>`;
            html += '</table>';
            settingsDiv.innerHTML = html;
            console.log('Settings loaded successfully');
        } else {
            console.error('Invalid response structure:', data);
            settingsDiv.innerHTML = '<div class="text-muted">設定データの構造が無効です</div>';
        }
    } catch (error) {
        console.error('Failed to load settings:', error);
        document.getElementById('currentSettings').innerHTML = 
            `<div class="text-muted">設定情報を取得できませんでした: ${error.message}</div>`;
    }
}

// モデル設定フォームの送信
document.getElementById('modelSettingsForm')?.addEventListener('submit', async (e) => {
    e.preventDefault();
    const formData = new FormData(e.target);
    const resultDiv = document.getElementById('modelSettingsResult');
    
    resultDiv.innerHTML = '<div class="alert alert-info">設定を保存中...</div>';
    
    try {
        const selectedModel = formData.get('model');
        console.log('選択されたモデル:', selectedModel);
        
        const settings = {
            llm_model: selectedModel,
            embedding_model: formData.get('embedding_model'),
            temperature: parseFloat(formData.get('temperature'))
        };
        
        console.log('送信する設定:', settings);
        
        const response = await fetch('/rag/update-settings', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(settings)
        });
        
        const responseData = await response.json();
        console.log('サーバーレスポンス:', responseData);
        
        if (response.ok && responseData.status === 'success') {
            resultDiv.innerHTML = '<div class="alert alert-success">✅ 設定を保存しました。新しいモデルが有効になりました。</div>';
            
            // 設定を即座に反映させる
            setTimeout(() => {
                loadCurrentSettings();
            }, 500);
        } else {
            throw new Error(responseData.message || '設定の保存に失敗しました');
        }
    } catch (error) {
        resultDiv.innerHTML = `<div class="alert alert-danger">エラー: ${error.message}</div>`;
    }
});

// 検索結果を保存
async function saveSearchResult() {
    if (!window.lastSearchResult) {
        alert('保存する検索結果がありません');
        return;
    }
    
    const name = prompt('保存名を入力してください（省略可）:');
    const tags = prompt('タグをカンマ区切りで入力してください（省略可）:');
    
    try {
        const response = await fetch('/rag/save-search', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                query_response: window.lastSearchResult,
                name: name || null,
                tags: tags ? tags.split(',').map(t => t.trim()) : null
            })
        });
        
        if (response.ok) {
            const data = await response.json();
            alert(`検索結果を保存しました (ID: ${data.result_id})`);
        } else {
            throw new Error('保存に失敗しました');
        }
    } catch (error) {
        alert(`エラー: ${error.message}`);
    }
}

// 検索履歴を表示
async function showSearchHistory() {
    const modalHtml = `
        <div class="modal fade" id="searchHistoryModal" tabindex="-1">
            <div class="modal-dialog modal-xl">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">📋 検索履歴</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                    </div>
                    <div class="modal-body" id="searchHistoryContent">
                        <div class="text-center">読み込み中...</div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">閉じる</button>
                        <button type="button" class="btn btn-primary" onclick="exportSelectedResults()">選択した結果をエクスポート</button>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    // モーダルが存在しない場合は追加
    if (!document.getElementById('searchHistoryModal')) {
        document.body.insertAdjacentHTML('beforeend', modalHtml);
    }
    
    // 少し遅延を入れてからモーダルを表示（DOM更新を待つ）
    setTimeout(() => {
        const modalElement = document.getElementById('searchHistoryModal');
        if (modalElement && typeof bootstrap !== 'undefined') {
            const modal = new bootstrap.Modal(modalElement);
            modal.show();
        } else {
            console.error('Bootstrap Modal not available');
            // フォールバック: 検索履歴タブに切り替える
            const historyTab = document.querySelector('a[href="#history"]');
            if (historyTab) {
                historyTab.click();
                loadSearchHistory();
            }
        }
    }, 100);
    
    // 履歴を読み込み
    try {
        const response = await fetch('/rag/search-history?limit=20');
        const data = await response.json();
        
        let html = '<div class="table-responsive">';
        html += '<table class="table table-hover">';
        html += '<thead><tr>';
        html += '<th><input type="checkbox" id="selectAllHistory"></th>';
        html += '<th>保存名</th>';
        html += '<th>クエリ</th>';
        html += '<th>信頼度</th>';
        html += '<th>保存日時</th>';
        html += '<th>操作</th>';
        html += '</tr></thead>';
        html += '<tbody>';
        
        data.results.forEach(result => {
            html += `<tr>`;
            html += `<td><input type="checkbox" class="history-checkbox" value="${result.id}"></td>`;
            html += `<td>${result.metadata?.name || '-'}</td>`;
            html += `<td>${result.query.substring(0, 50)}...</td>`;
            html += `<td>${(result.confidence_score * 100).toFixed(1)}%</td>`;
            html += `<td>${new Date(result.saved_at).toLocaleString('ja-JP', { 
                timeZone: 'Asia/Tokyo',
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            })}</td>`;
            html += `<td><button class="btn btn-sm btn-info" onclick="viewSavedResult('${result.id}')">詳細</button></td>`;
            html += '</tr>';
        });
        
        html += '</tbody></table></div>';
        
        document.getElementById('searchHistoryContent').innerHTML = html;
        
        // 全選択チェックボックスの処理
        document.getElementById('selectAllHistory')?.addEventListener('change', (e) => {
            document.querySelectorAll('.history-checkbox').forEach(cb => {
                cb.checked = e.target.checked;
            });
        });
        
    } catch (error) {
        document.getElementById('searchHistoryContent').innerHTML = 
            `<div class="alert alert-danger">履歴の読み込みに失敗しました: ${error.message}</div>`;
    }
}

// 保存された結果を表示
async function viewSavedResult(resultId) {
    try {
        const response = await fetch(`/rag/search-result/${resultId}`);
        const data = await response.json();
        
        // モーダルを閉じて、結果を表示
        bootstrap.Modal.getInstance(document.getElementById('searchHistoryModal'))?.hide();
        
        // 検索結果表示エリアに結果を表示
        const resultDiv = document.getElementById('searchResult');
        window.lastSearchResult = data;
        
        // 既存の表示関数を再利用（データ形式を調整）
        const formattedData = {
            query: data.query,
            answer: data.answer,
            citations: data.citations,
            sources: data.sources,
            confidence_score: data.confidence_score,
            processing_time: data.metadata?.processing_time || 0,
            metadata: data.metadata || {}
        };
        
        // 結果を表示（既存のコードを再利用）
        displaySearchResult(formattedData);
        
    } catch (error) {
        alert(`エラー: ${error.message}`);
    }
}

// 選択した結果をエクスポート
async function exportSelectedResults() {
    const selectedIds = Array.from(document.querySelectorAll('.history-checkbox:checked'))
        .map(cb => cb.value);
    
    if (selectedIds.length === 0) {
        alert('エクスポートする結果を選択してください');
        return;
    }
    
    const format = confirm('CSV形式でエクスポートしますか？（キャンセルでJSON形式）') ? 'csv' : 'json';
    
    try {
        const response = await fetch(`/rag/export-searches?result_ids=${selectedIds.join(',')}&format=${format}`);
        const blob = await response.blob();
        
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `search_results.${format}`;
        document.body.appendChild(a);
        a.click();
        window.URL.revokeObjectURL(url);
        document.body.removeChild(a);
        
    } catch (error) {
        alert(`エクスポートに失敗しました: ${error.message}`);
    }
}

// ページ読み込み時に実行
document.addEventListener('DOMContentLoaded', function() {
    // Bootstrapが利用可能かチェック
    if (typeof bootstrap !== 'undefined') {
        console.log('Bootstrap loaded successfully');
    } else {
        console.error('Bootstrap not loaded');
    }
    
    // 検索履歴タブがアクティブになったときに自動的に履歴を読み込む
    const historyTab = document.querySelector('a[href="#history"]');
    if (historyTab) {
        historyTab.addEventListener('shown.bs.tab', function() {
            loadSearchHistory();
        });
    }
    
    // 設定タブがアクティブになったときにLoRAモデルを読み込む
    const settingsTab = document.querySelector('a[href="#settings"]');
    if (settingsTab) {
        settingsTab.addEventListener('shown.bs.tab', function() {
            loadLoRAModels();
        });
    }
});

// 検索結果表示関数（再利用可能）
function displaySearchResult(data) {
    const resultDiv = document.getElementById('searchResult');
    const formattedAnswer = data.answer.replace(/\n/g, '<br>');
    
    let html = '<div class="card mt-3">';
    html += '<div class="card-body">';
    html += '<h4>💡 回答</h4>';
    html += `<div class="answer-content" style="white-space: pre-wrap; line-height: 1.6;">${formattedAnswer}</div>`;
    
    // 信頼度スコアの表示
    if (data.confidence_score !== undefined) {
        const confidence = (data.confidence_score * 100).toFixed(1);
        html += `<div class="mt-3">`;
        html += `<span class="badge bg-info">信頼度: ${confidence}%</span>`;
        if (data.metadata && data.metadata.fallback) {
            html += ` <span class="badge bg-warning">Fallback: ${data.metadata.fallback}</span>`;
        }
        html += `</div>`;
    }
    
    // 引用元の表示
    if (data.citations && data.citations.length > 0) {
        html += '<h5 class="mt-4">📚 引用・参考資料</h5>';
        html += '<div class="citations-list">';
        data.citations.forEach(cite => {
            html += '<div class="card mb-2">';
            html += '<div class="card-body" style="padding: 10px;">';
            html += `<strong>[出典: ${cite.source || '不明'}]</strong><br>`;
            html += `<small>${cite.text}</small>`;
            if (cite.score !== undefined) {
                html += `<br><span class="badge bg-secondary">スコア: ${cite.score.toFixed(3)}</span>`;
            }
            html += '</div></div>';
        });
        html += '</div>';
    }
    
    // 検索結果ソース
    if (data.sources && data.sources.length > 0) {
        html += '<h5 class="mt-4">🔍 検索結果詳細</h5>';
        html += '<table class="table table-sm">';
        html += '<thead><tr><th>タイトル</th><th>スコア</th></tr></thead>';
        html += '<tbody>';
        data.sources.forEach(source => {
            const score = source.score !== undefined ? source.score.toFixed(3) : 'N/A';
            html += `<tr>`;
            html += `<td>${source.title || source.metadata?.title || '不明'}</td>`;
            html += `<td>${score}</td>`;
            html += `</tr>`;
        });
        html += '</tbody></table>';
    }
    
    // 処理時間
    if (data.processing_time) {
        html += `<div class="text-muted mt-3">処理時間: ${data.processing_time.toFixed(2)}秒</div>`;
    }
    
    // 保存ボタン
    html += '<div class="mt-3">';
    html += '<button class="btn btn-success" onclick="saveSearchResult()">💾 検索結果を保存</button>';
    html += ' <button class="btn btn-info" onclick="showSearchHistory()">📋 検索履歴を表示</button>';
    html += '</div>';
    
    html += '</div></div>';
    
    window.lastSearchResult = data;
    resultDiv.innerHTML = html;
}

// 検索履歴タブ用の関数
let currentHistoryPage = 1;
let currentTagFilter = '';

async function loadSearchHistory(page = 1, tag = '') {
    const historyDiv = document.getElementById('historyList');
    historyDiv.innerHTML = '<div class="alert alert-info">読み込み中...</div>';
    
    currentHistoryPage = page;
    currentTagFilter = tag || document.getElementById('tagFilter')?.value || '';
    
    try {
        let url = `/rag/search-history?page=${page}&limit=10`;
        if (currentTagFilter) {
            url += `&tag=${encodeURIComponent(currentTagFilter)}`;
        }
        
        const response = await fetch(url);
        const data = await response.json();
        
        if (response.ok) {
            displayHistoryList(data);
            updateTagFilter(data.results);
        } else {
            throw new Error(data.detail || '履歴の読み込みに失敗しました');
        }
    } catch (error) {
        historyDiv.innerHTML = `<div class="alert alert-danger">エラー: ${error.message}</div>`;
    }
}

function displayHistoryList(data) {
    const historyDiv = document.getElementById('historyList');
    
    if (data.results.length === 0) {
        historyDiv.innerHTML = '<div class="text-muted">保存された検索履歴がありません</div>';
        return;
    }
    
    let html = '<div class="table-responsive">';
    html += '<table class="table table-hover">';
    html += '<thead><tr>';
    html += '<th>保存名</th>';
    html += '<th>クエリ</th>';
    html += '<th>信頼度</th>';
    html += '<th>保存日時</th>';
    html += '<th>操作</th>';
    html += '</tr></thead>';
    html += '<tbody>';
    
    data.results.forEach(result => {
        html += `<tr>`;
        html += `<td>${result.metadata?.name || '-'}</td>`;
        html += `<td title="${result.query}">${result.query.substring(0, 50)}${result.query.length > 50 ? '...' : ''}</td>`;
        html += `<td><span class="badge bg-info">${(result.confidence_score * 100).toFixed(1)}%</span></td>`;
        html += `<td><small>${new Date(result.saved_at).toLocaleString('ja-JP', { 
            timeZone: 'Asia/Tokyo',
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit'
        })}</small></td>`;
        html += `<td>`;
        html += `<button class="btn btn-sm btn-info me-1" onclick="viewSavedResultInTab('${result.id}')">表示</button>`;
        html += `<button class="btn btn-sm btn-danger" onclick="deleteSearchResult('${result.id}')" title="削除">`;
        html += `<i class="bi bi-trash"></i>`;
        html += `</button>`;
        html += `</td>`;
        html += '</tr>';
    });
    
    html += '</tbody></table></div>';
    historyDiv.innerHTML = html;
}

function updateTagFilter(results) {
    const tagSelect = document.getElementById('tagFilter');
    const existingTags = new Set();
    
    results.forEach(result => {
        const tags = result.metadata?.tags || [];
        tags.forEach(tag => existingTags.add(tag));
    });
    
    const currentValue = tagSelect.value;
    tagSelect.innerHTML = '<option value="">すべて</option>';
    
    existingTags.forEach(tag => {
        const option = document.createElement('option');
        option.value = tag;
        option.textContent = tag;
        if (tag === currentValue) {
            option.selected = true;
        }
        tagSelect.appendChild(option);
    });
}

async function viewSavedResultInTab(resultId) {
    try {
        const response = await fetch(`/rag/search-result/${resultId}`);
        const data = await response.json();
        
        // 検索タブに切り替え
        const searchTab = document.querySelector('a[href="#search"]');
        const tab = new bootstrap.Tab(searchTab);
        tab.show();
        
        // 結果を表示
        const formattedData = {
            query: data.query,
            answer: data.answer,
            citations: data.citations,
            sources: data.sources,
            confidence_score: data.confidence_score,
            processing_time: data.metadata?.processing_time || 0,
            metadata: data.metadata || {}
        };
        
        displaySearchResult(formattedData);
        
    } catch (error) {
        alert(`エラー: ${error.message}`);
    }
}

async function exportAllHistory() {
    try {
        const response = await fetch('/rag/search-history?limit=1000');
        const data = await response.json();
        
        if (data.results.length === 0) {
            alert('エクスポートする履歴がありません');
            return;
        }
        
        const format = confirm('CSV形式でエクスポートしますか？（キャンセルでJSON形式）') ? 'csv' : 'json';
        const allIds = data.results.map(r => r.id).join(',');
        
        const exportResponse = await fetch(`/rag/export-searches?result_ids=${allIds}&format=${format}`);
        const blob = await exportResponse.blob();
        
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `all_search_history.${format}`;
        document.body.appendChild(a);
        a.click();
        window.URL.revokeObjectURL(url);
        document.body.removeChild(a);
        
    } catch (error) {
        alert(`エクスポートに失敗しました: ${error.message}`);
    }
}

// 検索結果を削除
async function deleteSearchResult(resultId) {
    if (!confirm('この検索結果を削除しますか？')) {
        return;
    }
    
    try {
        const response = await fetch(`/rag/search-history/${resultId}`, {
            method: 'DELETE'
        });
        
        if (response.ok) {
            // 履歴リストをリロード
            loadSearchHistory(currentHistoryPage, currentTagFilter);
            showNotification('検索結果を削除しました', 'success');
        } else {
            const data = await response.json();
            console.error('Delete error response:', data);
            throw new Error(data.detail || '削除に失敗しました');
        }
    } catch (error) {
        console.error('Delete error:', error);
        showNotification(`削除エラー: ${error.message}`, 'danger');
    }
}

// 全ての検索履歴を削除
async function clearAllSearchHistory() {
    if (!confirm('すべての検索履歴を削除しますか？この操作は取り消せません。')) {
        return;
    }
    
    try {
        const response = await fetch('/rag/search-history/clear', {
            method: 'DELETE'
        });
        
        if (response.ok) {
            loadSearchHistory(1, '');
            showNotification('すべての検索履歴を削除しました', 'success');
        } else {
            const data = await response.json();
            throw new Error(data.detail || '削除に失敗しました');
        }
    } catch (error) {
        showNotification(`削除エラー: ${error.message}`, 'danger');
    }
}

// 通知を表示
function showNotification(message, type = 'info') {
    const alertDiv = document.createElement('div');
    alertDiv.className = `alert alert-${type} alert-dismissible fade show position-fixed top-0 start-50 translate-middle-x mt-3`;
    alertDiv.style.zIndex = '9999';
    alertDiv.innerHTML = `
        ${message}
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    `;
    document.body.appendChild(alertDiv);
    
    setTimeout(() => {
        alertDiv.remove();
    }, 3000);
}

// 文書チェックボックスリストを読み込む関数
async function loadDocumentCheckboxList() {
    const listDiv = document.getElementById('documentCheckboxList');
    if (!listDiv) return;
    
    try {
        const response = await fetch('/rag/documents');
        const data = await response.json();
        
        if (response.ok && data.documents) {
            if (data.documents.length === 0) {
                listDiv.innerHTML = '<div class="col-12"><div class="alert alert-warning">アップロードされた文書がありません。</div></div>';
                return;
            }
            
            let html = '';
            data.documents.forEach((doc, index) => {
                const docId = doc.id || doc.filename?.replace('.pdf', '');
                const title = doc.title || doc.filename || 'Untitled';
                const truncatedTitle = title.length > 30 ? title.substring(0, 30) + '...' : title;
                
                html += `
                    <div class="col-md-6 col-lg-4 mb-2">
                        <div class="form-check">
                            <input class="form-check-input document-checkbox" 
                                   type="checkbox" 
                                   value="${docId}" 
                                   id="doc_${index}"
                                   checked>
                            <label class="form-check-label" for="doc_${index}" title="${title}">
                                ${truncatedTitle}
                            </label>
                        </div>
                    </div>
                `;
            });
            
            listDiv.innerHTML = html;
            
            // 全選択チェックボックスのイベントリスナー
            const selectAllCheckbox = document.getElementById('selectAllDocuments');
            if (selectAllCheckbox) {
                selectAllCheckbox.addEventListener('change', (e) => {
                    const checkboxes = document.querySelectorAll('.document-checkbox');
                    checkboxes.forEach(checkbox => {
                        checkbox.checked = e.target.checked;
                    });
                });
            }
            
            // 個別チェックボックスの変更時に全選択チェックボックスを更新
            document.querySelectorAll('.document-checkbox').forEach(checkbox => {
                checkbox.addEventListener('change', () => {
                    const allCheckboxes = document.querySelectorAll('.document-checkbox');
                    const checkedCheckboxes = document.querySelectorAll('.document-checkbox:checked');
                    const selectAllCheckbox = document.getElementById('selectAllDocuments');
                    
                    if (selectAllCheckbox) {
                        selectAllCheckbox.checked = allCheckboxes.length === checkedCheckboxes.length;
                        selectAllCheckbox.indeterminate = checkedCheckboxes.length > 0 && checkedCheckboxes.length < allCheckboxes.length;
                    }
                });
            });
        }
    } catch (error) {
        console.error('文書リスト取得エラー:', error);
        listDiv.innerHTML = '<div class="col-12"><div class="alert alert-danger">文書リストの取得に失敗しました。</div></div>';
    }
}

// ページ読み込み時に実行
document.addEventListener('DOMContentLoaded', () => {
    // RAGが利用可能な場合のみ実行
    loadFinetunedModels();
    loadCurrentSettings();
    loadDocumentCheckboxList();  // 文書チェックボックスリストを読み込む
    loadLoRAModels();  // LoRAモデルリストを動的に読み込む
});
</script>
{% endblock %}